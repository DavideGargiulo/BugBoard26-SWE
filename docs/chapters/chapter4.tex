\chapter{Documento di Design del sistema}

\section{Obiettivi di Design}

Gli obiettivi di design del sistema si basano sugli attributi di qualità del software definiti nello
standard ISO/IEC 25002. Per priorizzare tali obiettivi, è stato adottato un sistema di
ponderazione da 1 a 5, dove 5 indica la massima priorità, in funzione dell'impatto specifico di
ciascuna caratteristica sulle funzionalità da implementare.

\subsection{Analisi delle Caratteristiche di Qualità}

\begin{itemize}
  \item \textbf{Functional Suitability (5/5)} \\
        L'idoneità funzionale è centrale per garantire che il flusso di gestione delle anomalie supporti efficacemente il processo di QA aziendale.
        La \textbf{functional completeness (5/5)} è garantita dalla copertura esaustiva dei casi d'uso necessari per il tracking, inclusa la creazione di issue con tipologie diversificate (Bug, Feature, Question), la gestione di allegati e il sistema di commenti per la collaborazione.
        La \textbf{functional correctness (5/5)} è assicurata dalle rigorose validazioni implementate nel backend, che prevengono la creazione di ticket con dati incompleti o incoerenti, e verificata tramite test automatici specifici.
        La \textbf{functional appropriateness (5/5)} si riflette nella segregazione dei compiti tra ruoli "Standard" e "Admin", fornendo a ciascun utente esattamente le funzionalità pertinenti al proprio livello di responsabilità.
  \\
  \item \textbf{Reliability (4/5)} \\
        L'affidabilità del sistema è solida, garantendo continuità e robustezza operativa. La \textbf{faultlessness (4/5)} è perseguita attraverso l'uso di strumenti di analisi statica e una suite di test automatizzati con \texttt{Vitest} che verifica il comportamento corretto delle API, riducendo la presenza di difetti nel codice.
        L'\textbf{Availability (4/5)} è assicurata dall'architettura containerizzata: i servizi critici come Postgres e Keycloak dispongono di healthcheck dedicati che prevengono l'avvio del backend finché le dipendenze non sono operative, massimizzando il tempo di attività del servizio.
        La \textbf{fault tolerance (4/5)} è gestita efficacemente a livello applicativo; i controller utilizzano blocchi try/catch per intercettare eccezioni impreviste senza causare il crash dell'intero servizio, restituendo invece errori strutturati al client.
        La \textbf{recoverability (3/5)} è implementata tramite meccanismi di rollback manuale, come la funzione cleanupFiles che elimina i file caricati se la transazione di creazione della issue fallisce, ripristinando uno stato consistente del sistema.
  \newpage
  \item \textbf{Security (5/5)} \\
        La sicurezza è gestita in modo rigoroso, adottando standard industriali per la protezione del sistema. La \textbf{confidentiality (5/5)} è garantita dall'integrazione con Keycloak, che protegge le risorse tramite token JWT cifrati; l'accesso agli endpoint sensibili è regolato da middleware come protect e checkRole, assicurando che solo gli utenti autorizzati visualizzino i dati.
        L'\textbf{integrity (5/5)} è assicurata per gli allegati tramite il calcolo dell'hash SHA256 al momento dell'upload, permettendo di verificare che i file non siano stati alterati.
        L'\textbf{authenticity (5/5)} viene verificata crittograficamente: il backend valida la firma digitale dei token JWT utilizzando le chiavi pubbliche (JWKS) esposte da Keycloak, garantendo con certezza l'identità del mittente.
        La \textbf{non-repudiation (4/5)} è supportata dalla persistenza dei dati: ogni issue e commento creato è indissolubilmente legato all'ID univoco dell'utente nel database, rendendo innegabile la paternità dell'azione all'interno del sistema.
        Infine, l'\textbf{accountability (5/5)} è totale, poiché ogni richiesta che modifica lo stato del sistema passa attraverso il middleware di autenticazione che traccia l'utente responsabile prima di eseguire qualsiasi operazione sui controller.
  \\
  \item \textbf{Performace Efficiency (3/5)} \\
        L'efficienza risente della centralizzazione della logica nel layer backend monolitico. Il \textbf{time behaviour (3/5)} è penalizzato da alcune implementazioni nel layer di accesso ai dati, come il problema "N+1" nel controller delle issue che esegue una query di conteggio per ogni elemento restituito, rallentando la risposta complessiva del server.
        La \textbf{resource utilization (3/5)} è critica nel layer applicativo, poiché la gestione degli allegati carica interi file in buffer di memoria direttamente nel processo Node.js principale, rischiando di saturare le risorse del container backend in caso di picchi di utilizzo.
        La \textbf{capacity (4/5)} rimane comunque buona grazie alla separazione netta degli strati via Docker Compose, che permette di allocare risorse dedicate o scalare il layer backend indipendentemente dal database e dal frontend.
  \\
  \item \textbf{Usability (4/5)} \\
        L'usabilità è progettata per garantire un'interazione intuitiva e accessibile. La \textbf{recognizability (5/5)} è eccellente: la presenza di una dashboard iniziale con grafici a torta permette agli utenti di comprendere immediatamente lo scopo del sistema e lo stato corrente delle issue, mentre la navigazione tramite sidebar rende esplicite le funzionalità disponibili.
        L'\textbf{inclusivity (4/5)} è supportata dall'adozione del framework Angular Material, che fornisce componenti nativamente accessibili (come campi di input con etichette chiare e contrasto adeguato), facilitando l'uso anche a utenti con diverse abilità visive.
        La \textbf{learnability (4/5)} è favorita da un'interfaccia coerente e moderna (Tailwind CSS), che riduce la curva di apprendimento per i nuovi membri del team.
        L'\textbf{operability (4/5)} è garantita da flussi di lavoro lineari e dialoghi di conferma (es. toast) che prevengono errori operativi durante azioni critiche come l'eliminazione.
  \newpage
  \item \textbf{Compatibility (5/5)} \\
        La compatibilità è essenziale per l'integrazione in ambienti di sviluppo eterogenei. La \textbf{co-existence (5/5)} è eccellente grazie all'uso di Docker Compose, che isola completamente le dipendenze (DB, Keycloak, Backend) evitando conflitti con altro software installato sulla macchina host.
        L'\textbf{interoperability (5/5)} è garantita dall'adozione di standard aperti come REST per le API, JSON per lo scambio dati e OIDC per l'autenticazione, permettendo al sistema di dialogare facilmente con altri strumenti aziendali.
  \\
  \item \textbf{Maintainability (5/5)} \\
        La manutenibilità è un punto di forza, strutturata per facilitare evoluzioni future. La \textbf{modularity (5/5)} è garantita dalla netta separazione delle responsabilità nel backend tra controller, rotte e modelli dati, e nel frontend tramite l'architettura a componenti di Angular.
        La \textbf{reusability (5/5)} è massimizzata dall'uso di middleware generici per funzioni trasversali come l'autenticazione e la gestione dei file, riutilizzabili su diverse rotte.
        La \textbf{testability (5/5)} è assicurata da un'infrastruttura di testing pronta con l'utilizzo di \texttt{Vitest}.
        La \textbf{modifiability (5/5)} è supportata dall'uso dell'ORM Sequelize, che astrae le query SQL permettendo di modificare lo schema del database o la logica di business con impatti minimi sul resto del codice, e dalla configurazione esternalizzata in file \texttt{.env} che facilita i cambi di ambiente senza ricompilazione.
  \\
  \item \textbf{Flexibility (4/5)} \\
        La flessibilità determina la capacità del software di adattarsi a nuovi contesti e tecnologie. L'\textbf{adaptability (4/5)} è gestita tramite un ampio uso di variabili d'ambiente che permettono di riconfigurare database, porte e URL di servizi esterni senza modificare il codice sorgente.
        La \textbf{scalability (4/5)} è intrinseca nell'architettura a container, permettendo di scalare orizzontalmente i servizi stateless come il backend e il frontend.
        L'\textbf{installability (3/5)} è buona grazie a Docker Compose, ma il punteggio è ridotto dalla necessità di configurare manualmente il file .env prima dell'avvio, introducendo un passaggio manuale obbligatorio che impedisce un deployment totalmente automatico "out-of-the-box".
        Infine, la \textbf{replaceability (4/5)} è supportata dall'uso dell'ORM Sequelize, che facilita la sostituzione del database PostgreSQL con altri dialetti SQL minimizzando le modifiche al codice.
  \\
  \item \textbf{Safety (3/5)} \\
        La sicurezza intesa come assenza di rischi (Safety) riguarda la prevenzione di danni critici. Sebbene in un bug tracker il rischio fisico sia nullo, l'\textbf{operational safety (3/5)} è garantita da meccanismi che prevenendo la corruzione dei dati o l'accumulo di "rifiuti" digitali, come la cancellazione automatica dei file caricati se la transazione database fallisce.
        La \textbf{risk identification (3/5)} è mitigata dalle restrizioni sui ruoli, impedendo che utenti inesperti possano compromettere la configurazione dei progetti o degli utenti critici.
\end{itemize}

\newpage

\subsection{Tabella riassuntiva delle priorità delle qualità del software}

Di seguito è presentata una tabella riassuntiva delle valutazioni di priorità assegnate alle qualità
del software analizzate.

\begin{longtable}{|>{\centering\arraybackslash\bfseries}p{7cm}|p{7cm}|}
  \hline
  \rowcolor{airforceblue!80!cyan}
  \textcolor{white}{\textbf{Qualità}} & \textcolor{white}{\textbf{Punteggio}} \\
  \hline
  \endfirsthead
  \endhead

  \rowcolor{beaublue!30}
  \textit{Functional suitability} & 5 \\ \hline
  Reliability  & 4 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Security} & 5 \\ \hline
  Performace Efficiency & 3 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Usability} & 4 \\ \hline
  Compatibility & 5 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Maintainability} & 5 \\ \hline
  Flexibility & 4 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Safety} & 3 \\ \hline
\end{longtable}

\newpage

\subsection{Considerazioni sul Tempo di rilascio e Trade-offs}

Il \textbf{Time to Release} rappresenta un vincolo critico del progetto, subordinato esclusivamente alla \textit{Functional Suitability} e alla \textit{Security}. La pressione temporale imposta dalle scadenze operative ha determinato trade-offs consapevoli tra qualità del software concorrenti, privilegiando il rilascio rapido di funzionalità essenziali rispetto all'ottimizzazione spinta di attributi secondari.

\begin{itemize}
  \item \textbf{Time to Release vs Code Quality} \\
        L'introduzione controllata di technical debt è stata accettata per rispettare le milestone di progetto, garantendo comunque la correttezza funzionale tramite test automatizzati con \texttt{Vitest}.
  \\
  \item \textbf{Time to Release vs Performance Efficiency} \\
        L'adozione dell'ORM Sequelize ha accelerato lo sviluppo del layer di persistenza eliminando la necessità di scrivere query SQL manuali, introducendo però un overhead computazionale fisiologico. L'implementazione diretta di query ottimizzate avrebbe richiesto un dispendio temporale incompatibile con la priorità del rilascio.
  \\
  \item \textbf{Time to Release vs Functional Suitability} \\
        La definizione rigorosa del perimetro funzionale ha limitato lo scope alle funzionalità essenziali: creazione, lettura, aggiornamento ed eliminazione di issue con sistema di commenti e allegati.
  \\
  \item \textbf{Safety vs Performance Efficiency} \\
        I meccanismi di \textbf{operational safety} implementati introducono overhead elaborativo aggiuntivo per ogni transazione. La funzione \texttt{cleanupFiles} esegue operazioni di filesystem I/O sincrone per garantire la rimozione degli allegati orfani in caso di rollback del database, rallentando il throughput delle operazioni di creazione issue ma prevenendo la corruzione dello stato del sistema e l'accumulo di risorse non referenziate.
  \\
  \item \textbf{Security vs Time to Release} \\
        Nonostante la pressione temporale, la \textbf{Security} non è stata compromessa. L'integrazione con Keycloak per la gestione di autenticazione e autorizzazione tramite token JWT, la validazione crittografica delle firme digitali con JWKS, e il calcolo dell'hash SHA256 per l'integrità degli allegati sono stati implementati integralmente sin dalla prima release, riconoscendo il rischio elevato di exploitation di vulnerabilità legate a bug leak o privilege escalation.
\end{itemize}

\newpage

\section{Decomposizione del sistema}

Per poter comprendere quale architettura fosse adatta per questo progetto, abbiamo analizzato diverse alternative concentrandoci però sugli aspetti chiave di essi:

\begin{itemize}
  \item \textbf{Architetture Standard vs. Architetture Moderne} \\
        L'analisi ha confrontato l'adozione di architetture consolidate, come quella monolitica a strati (layered architecture), con paradigmi più recenti quali microservizi e architetture event-driven. Pur riconoscendo i benefici di approcci distribuiti in termini di scalabilità orizzontale, fault isolation e autonomia dei team, tali soluzioni comportano un overhead significativo nella gestione della comunicazione inter-service, nell'orchestrazione del deployment e nel monitoraggio distribuito. Considerando le caratteristiche del progetto — un perimetro funzionale ben definito, un team di sviluppo ridotto e vincoli temporali stringenti — un'architettura monolitica a strati si è rivelata la scelta ottimale, bilanciando efficacemente semplicità operativa ed efficienza nello sviluppo. Questa decisione ha consentito di allocare le risorse disponibili sull'implementazione delle funzionalità core del sistema, evitando la complessità architetturale non necessaria per la scala operativa prevista.
  \\
  \item \textbf{Persistenza dei Dati} \\
        La natura strutturata delle informazioni gestite dal sistema — issue con metadati
        tipizzati, relazioni tra utenti e progetti, commenti gerarchici e allegati referenziati —
        ha reso necessaria l'adozione di un database relazionale (RDBMS). PostgreSQL è
        stato selezionato per la sua robustezza nelle operazioni transazionali ACID,
        essenziali per garantire la consistenza tra la creazione di issue e il caricamento di
        allegati, e per il supporto nativo a vincoli di integrità referenziale che prevengono
        la corruzione dei dati in caso di operazioni concorrenti. L'integrazione con
        Sequelize ORM ha ulteriormente semplificato l'accesso ai dati, astraendo la
        complessità delle query SQL e massimizzando la \textbf{modifiability} del
        layer di persistenza. Alternative NoSQL, pur offrendo scalabilità orizzontale
        superiore, avrebbero compromesso la capacità di eseguire query complesse con
        filtri multipli (per tipo, stato, progetto, assegnatario) e join tra entità correlate,
        funzionalità core del sistema di ricerca implementato nel frontend.
  \\
  \item \textbf{Cloud vs On-Premise} \\
        Il deployment del sistema è stato progettato per ambienti cloud, sfruttando
        la containerizzazione tramite Docker Compose per garantire portabilità e
        isolamento delle dipendenze. Questa scelta elimina la necessità di gestire infrastruttura fisica dedicata e
        semplificando drasticamente le operazioni di provisioning e scaling.
        L'architettura containerizzata permette il deployment su qualsiasi provider
        cloud o su infrastrutture on-premise virtualizzate,
        mantenendo la \textbf{co-existence} con altri servizi aziendali senza
        conflitti di dipendenze. Un deployment on-premise tradizionale richiederebbe configurazioni manuali per PostgreSQL, Keycloak e Node.js su
        ciascun ambiente. La soluzione
        cloud consente inoltre di delegare aspetti infrastrutturali critici come
        backup automatici, disaster recovery e aggiornamenti di sicurezza al provider,
        liberando risorse del team per lo sviluppo delle funzionalità core.
  \newpage
  \item \textbf{Buy vs Build} \\
        Nonostante la pressione temporale derivante dal \textbf{Time to Release},
        la scelta è ricaduta sull'opzione "build", sviluppando il sistema internamente
        piuttosto che adottare soluzioni commerciali preesistenti come Jira, GitLab
        Issues o Bugzilla. Questa decisione è stata motivata principalmente da
        requisiti di \textbf{Functional Suitability} specifici per i processi di
        QA aziendali, che richiedevano workflow personalizzati e integrazioni con
        sistemi interni non supportate da strumenti generici. Tuttavia, per componenti
        infrastrutturali critici ma non differenzianti, è stata privilegiata
        l'integrazione con software open-source maturo: Keycloak in modalità headless come Identity
        Provider self-hosted garantisce standard industriali di \textbf{Security}
        (autenticazione OIDC, gestione realm con ruoli "Standard" e "Amministratore",
        validazione JWT tramite JWKS) senza dover implementare da zero logiche
        complesse di Identity and Access Management. L'infrastruttura cloud è
        affidata ad Amazon Web Services (AWS), che fornisce compute tramite EC2
        per l'esecuzione dei container Docker (frontend Angular, backend Node.js,
        database PostgreSQL e Keycloak stesso). Questo approccio ibrido ha bilanciato
        il controllo completo sulle funzionalità core del bug tracker con l'efficienza
        derivante dall'utilizzo di componenti consolidate per aspetti trasversali,
        evitando il rischio di reinventare soluzioni già disponibili e battle-tested.
  \\
  \item \textbf{Complessità del Sistema e Prospettive Future} \\
        La complessità contenuta del sistema, caratterizzato da un perimetro
        funzionale ben definito e da incertezze sulla sua evoluzione a lungo termine,
        ha reso ingiustificata l'adozione prematura di architetture distribuite come i
        microservizi, che avrebbero introdotto un livello di complessità eccessivo
        (over-engineering) rispetto alle necessità operative attuali. Tale approccio
        avrebbe inoltre compromesso significativamente il \textbf{Time to Release}, imponendo overhead di gestione, orchestrazione e monitoring
        sproporzionati alla scala del progetto. Ciononostante, la scelta di
        un'architettura containerizzata su cloud AWS e l'integrazione con servizi
        gestiti come Keycloak garantiscono la flessibilità necessaria per una
        potenziale migrazione verso pattern architetturali più distribuiti qualora le
        esigenze future del sistema richiedano maggiore scalabilità orizzontale,
        resilienza o autonomia dei componenti. L'adozione di standard aperti
        (REST API, OIDC, Docker) e la separazione netta dei layer preservano la
        \textbf{modifiability} necessaria per evolvere l'architettura senza
        riscritture sostanziali del codice esistente.
\end{itemize}

\newpage

\subsection{La Scelta Architetturale: Un "Monolite Modulare con Servizi Esterni"}

Dopo una attenta analisi considerando pro e contro di ogni architettura, abbiamo dunque dedotto che la migliore opzione per l'architettura per questo progetto fosse un monolite modulare ma con l'utilizzo di servizi esterni, come per esempio l'identity provider.
Tale architettura offre molti vantaggi, ovvero quelli di un'architettura monolitica a strati con l'ausilio di servizi indipendenti, offerti da servizi cloud come Amazon AWS.
Questa soluzione è stata la scelta più adeguata data la sua semplicità di implementazione iniziale, ma soprattutto per i suoi vantaggi di scalabilità futura.

Nello specifico, le funzionalità core del sistema, ovvero la logica di business principale (ad esempio la creazione di una issue, commentare una issue etc),
saranno implementate all'interno di un'architettura monolitica a strati ben definita.
Parallelamente, utilizzeremo servizi esterni per gestire funzionalità trasversali come l'autenticazione.

\subsection{Strutturazione del core monolitico}

Il core monolitico conterrà le funzionalità principali del sistema. Tale monolite è diviso in 5 layer principali:
\begin{itemize}
  \item \textbf{User Interface};
  \item \textbf{Presentation Logic};
  \item \textbf{Application Logic};
  \item \textbf{Data Access};
  \item \textbf{Data Storage}.
\end{itemize}

In particolare ogni layer si occuperà di:

\begin{itemize}
  \item \textbf{User Interface} \\
        La User Interface, comunemente detta UI, si occupa della presentazione visiva e di tutto ciò che riguarda l'interazione dell'utente finale. Esso contiene tutti gli elementi dell'interfaccia e si limita a raccogliere gli input dell'utente e presentare i risultati forniti dal layer di presentation logic.
  \\
  \item \textbf{Presentation Logic} \\
        Il layer di presentation è responsabile della formattazione dei dati per la visualizzazione all'utente e alle interazioni dell'utente. In pratica prende le richieste dal layer di user interface, le inoltra al layer di application logic e formatta i risultati ottenuti nell'interfaccia utente.
  \\
  \item \textbf{Application Logic} \\
        Il layer di application contiene tutta la logica di business, ovvero tutte le regole e tutti i processi che definiscono il funzionamento del sistema. Fa tutto ciò esponendo gli API (Application programming interface) end-point del backend e si occupa di gestire la logica di business.
  \newpage
  \item \textbf{Data Access} \\
        Il layer di data access si occupa dell'interazione con i sistemi di persistenza dei dati. Fornisce un livello di astrazione maggiore rispetto all'implementazione specifica del database in sé, consentendo al layer di application logic di interagire con i dati non preoccupandosi di query SQL etc.
  \\
  \item \textbf{Data Storage} \\
        Il layer data storage rappresenta l'effettiva implementazione della persistenza dei dati. Principalmente include il database relazionale.
\end{itemize}

\subsection{Servizio Cross-Layer Esternalizzato}

L'unico servizio esternalizzato è il servizio di \textbf{identity provider}.

\subsection{Comunicazione tra parti del sistema}

L'architettura del sistema è progettata come un'architettura aperta, tenendo conto della presenza del servizio cross-layer. Inoltre, alcuni layer come quello di presentation logic, devono comunicare con più parti del sistema per soddisfare i requisiti funzionali.

Inoltre, considerando esclusivamente il core monolitico dell'architettura, la comunicazione tra i vari layer segue un paradigma di architettura chiusa. Questo approccio è scelto per garantire una chiara separazione delle responsabilità di tutti i layer. Tale separazione porta molti vantaggi tra cui il miglioramento della manutenibilità e la facilità di effettuare eventuali modifiche o evoluzioni del sistema.

\newpage

\section{Identificazione dei Threads}

Nel layer di presentation logic vengono sfruttati dei threads per consentire il caricamento dei dati in parallelo rispetto al caricamento della pagina principale. Questa strategia permette di migliorare significativamente le performance complessive dell'applicazione, evitando che operazioni potenzialmente lunghe blocchino il rendering dell'interfaccia utente. In particolare, i threads vengono utilizzati per eseguire richieste asincrone verso il backend, elaborare dati complessi o effettuare chiamate a servizi esterni, garantendo così un'esperienza utente più fluida e reattiva. L'adozione di questo approccio multi-threading consente inoltre di sfruttare al meglio le risorse hardware disponibili, distribuendo il carico di lavoro su più unità di elaborazione.

\subsection{Parallelismo e Asincronismo}

L'adozione di meccanismi di parallelismo e asincronismo è fondamentale per migliorare l'efficienza di alcune operazioni, soprattutto quando il carico di lavoro è elevato. Alcuni esempi di caso d'uso significativi di queste tecniche sono:

\begin{itemize}
  \item \textbf{Gestione Concorrente degli Allegati} \\
        Durante la creazione o l'aggiornamento di una issue, il sistema deve gestire l'upload di molteplici file (immagini o PDF). Nel controller createIssue e nella funzione helper createAttachments, il codice non processa i file in sequenza. Viene invece creato un array di Promises mappando i file in ingresso: per ciascun file vengono avviate simultaneamente le operazioni di lettura dal disco (fsPromises.readFile), calcolo dell'hash crittografico (SHA256) e inserimento nel database. L'uso di Promise.all attende che tutte queste operazioni parallele siano completate prima di restituire la risposta, riducendo drasticamente il tempo di attesa complessivo per l'utente rispetto a un'esecuzione sequenziale.
  \\
  \item \textbf{Aggregazione Dati per le Liste:}
        Nella funzione `fetchIssuesWithComments`, utilizzata per recuperare la lista delle issue da mostrare nella dashboard, il sistema deve associare a ogni issue il numero dei suoi commenti. Invece di iterare e attendere sequenzialmente il conteggio per ogni singola issue (che causerebbe un forte rallentamento), il sistema lancia tutte le query di conteggio (`countCommentsByIssueId`) in parallelo utilizzando `Promise.all` su una mappa delle issue trovate. Questo permette di sfruttare la capacità del database di gestire connessioni concorrenti.
  \\
  \item \textbf{Rollback e Pulizia delle Risorse:}
        Nel caso in cui la creazione di una issue fallisca (ad esempio per errori di validazione o database), la funzione `cleanupFiles` garantisce che i file fisici caricati vengano rimossi per non lasciare "rifiuti". Anche questa operazione sfrutta il parallelismo: viene generata una lista di operazioni di cancellazione (`fsPromises.unlink`) che vengono eseguite simultaneamente tramite `Promise.all`, minimizzando il tempo impiegato per la gestione dell'errore.
\end{itemize}

\newpage

\section{Descrizione e motivazione delle scelte tecnologiche adottate}

\subsection{Hardware-Software Mapping}

Come discusso nelle sezioni precedenti, l'architettura del sistema fa uso di tecnologie cloud per garantire scalabilità, flessibilità e una gestione semplificata delle risorse in generale.
Per rendere l'applicazione accessibile via rete, si utilizzeranno i servizi offerti da Amazon Web Services (AWS). Quindi la struttura sarà organizzata come di seguito

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/Diagrammi_architettura2.png}
  \caption{Figura rappresentante il sistema}
\end{figure}

\newpage

\subsection{Distribuzioni delle Componenti del Sistema}

\subsubsection{Layer del Core Monolitico}

Le varie parti del sistema sono distribuite tra il client dell'utente e un'infrastruttura cloud basata su container. Ecco i dettagli:

\begin{itemize}
  \item \textbf{User Interface e Presentation Logic Layer} \\
        Questi due layer sono realizzati come \textbf{Web Application SPA (Single Page Applicaton)} e vengono eseguiti direttamente all'interno del browser sul dispositivo dell'utente.
        Il browser scarica il bundle frontend (Angular) fornito dal server e gestisce la logica di presentazione localmente, garantendo un'esperienza utente reattiva senza gravare sul server per il rendering dell'interfaccia.
  \\
  \item \textbf{Application Layer e Data Access Layer} \\
        Questi layer costituiscono il cuore del backend e sono incapsulati in container Docker. L'orchestrazione avviene tramite \textbf{Docker Compose} su una macchina virtuale \textbf{AWS EC2} (Amazon Elastic Compute Cloud). Questa scelta permette di avere un ambiente riproducibile e isolato, dove la logica di business viene eseguita all'interno del proprio container dedicato.
  \\
  \item \textbf{Data Storage Layer} \\
        La persistenza dei dati è gestita interamente all'interno dell'ecosistema Docker sulla macchina virtuale, utilizzando volumi per garantire la durata dei dati:
        \begin{itemize}
          \item Il database relazionale PostgreSQL è ospitato in un container dedicato definito nel docker-compose, che sostituisce la necessità di un servizio gestito esterno;
          \item Gli allegati vengono salvati sul file system locale tramite volumi Docker collegati al container di backend, gestiti direttamente dalle API di upload del sistema.
        \end{itemize}
\end{itemize}

\subsubsection{Servizi Cross-Layer}

Alcune funzionalità trasversali al sistema sono state esternalizzate a servizi specializzati, ospitati in container dedicati, per ottimizzare la gestione delle identità e garantire la scalabilità:

\begin{itemize}
  \item \textbf{Autenticazione e Gestione Identità} \\
        Gestita tramite Keycloak, una soluzione di Identity and Access Management open-source. Per integrarsi perfettamente con l'interfaccia utente personalizzata sviluppata in Angular, Keycloak è utilizzato in modalità "headless": il frontend gestisce i form di accesso e comunica con il backend, che agisce da intermediario sicuro per la validazione delle credenziali e l'emissione dei token JWT, senza reindirizzare l'utente su pagine di login esterne.
\end{itemize}

\newpage

\section{Descrizione dello schema per la persistenza dati (Database)}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/dbschema.png}
\end{figure}

\subsection{Il Ruolo del Database nel Sistema}

Contrariamente ai paradigmi Database-Centric che delegano la logica di business a stored procedures complesse, l'architettura di sistema adotta un approccio moderno basato su ORM (Sequelize). Il database PostgreSQL, containerizzato via Docker, agisce come Persistence Layer robusto, responsabile dell'integrità referenziale e della consistenza dei dati (ACID), mentre la logica di business complessa è centralizzata nel Backend. Tuttavia, per garantire la massima coerenza dei dati critici indipendentemente dal flusso applicativo, sono stati implementati mirati meccanismi attivi nel database, come Trigger per l'aggiornamento automatico degli stati e vincoli di integrità (Check Constraints) per la validazione degli allegati.

\newpage

\subsection{PostgreSQL come Motore di Persistenza Relazionale}

La scelta di PostgreSQL come foundation tecnologica deriva dalla necessità di garantire la massima integrità e consistenza dei dati in un ambiente multi-utente. Più che una semplice memoria di massa, il database agisce come garante ultimo della qualità del dato.

Le capacità avanzate di PostgreSQL sono sfruttate in modo mirato per rinforzare la logica di dominio:

\begin{itemize}
  \item \textbf{Type Safety e Enum} \\
        L'utilizzo di tipi enumerativi personalizzati per stati, ruoli e priorità assicura che il sistema gestisca solo valori semanticamente validi, prevenendo errori di incoerenza a livello strutturale.
  \item \textbf{Integrità Referenziale Avanzata} \\
        L'architettura fa ampio uso di vincoli FOREIGN KEY con clausole ON DELETE CASCADE per gestire automaticamente la pulizia dei dati correlati (es. eliminazione di issue e commenti quando viene eliminato un progetto), semplificando la logica applicativa.
  \item \textbf{Vincoli Complessi} \\
        Sono implementati CHECK constraints sofisticati, come la logica XOR sulla tabella allegati (che garantisce l'appartenenza esclusiva a issue o commenti), delegando al database la validazione di invarianti critiche che potrebbero sfuggire al livello applicativo.
\end{itemize}

\subsection{Sistema di Tipi e Valutazione: Type Safety nel Database}

\subsubsection{Sistema di Tipi Personalizzati}

Per modellare fedelmente il dominio del problema, sono stati definiti tipi enumerativi personalizzati che restringono il campo dei valori ammissibili per attributi critici, eliminando l'ambiguità delle stringhe libere:

\begin{itemize}
  \item \textbf{Ruoli e Permessi} \\
        Il tipo ruolo ('Amministratore', 'Standard') centralizza la definizione della gerarchia utenti.
  \\
  \item \textbf{Workflow delle Issue} \\
        I tipi tipo\_issue ('Bug', 'Feature', ecc.) e stato\_issue ('TODO', 'In-Progress', 'Done') cristallizzano il ciclo di vita delle segnalazioni direttamente nello schema del database, impedendo l'inserimento di stati non riconosciuti dal sistema.
\end{itemize}

\newpage

\subsubsection{Validazione Strutturale e Constraints}

Oltre ai vincoli standard di unicità e chiave esterna, sono stati implementati vincoli CHECK complessi per garantire regole di business strutturali:

\begin{itemize}
  \item \textbf{Integrità Polimorfica degli Allegati} \\
        La tabella allegato utilizza un vincolo logico XOR per garantire che un file sia associato esclusivamente a un commento O a una issue, ma mai a entrambi o a nessuno. Questo previene record orfani o relazioni ambigue a livello strutturale.
  \\
  \item \textbf{Limiti Fisici} \\
        È stato imposto un vincolo rigido sulla dimensione dei file (dimensione\_byte <= 5242880), assicurando che il database rifiuti transazioni che violano i requisiti non funzionali di storage, fungendo da ultima linea di difesa contro errori di validazione nel frontend.
\end{itemize}

\section{Evoluzione e Manutenibilità del Sistema}

\subsection{Architettura Evolutiva e Modularità}

Il sistema è stato progettato seguendo un'architettura a livelli (Layered Architecture) che favorisce la manutenibilità e l'evoluzione indipendente dei componenti. La separazione netta tra il livello di presentazione (Frontend Angular), la logica di business (Backend Node.js) e la persistenza dei dati (PostgreSQL) permette modifiche mirate senza effetti a cascata.

\subsection{Osservabilità e Diagnostica}

Per quanto riguarda osservabilità e diagnostica, ci affidiamo alla robustezza dell'infrastruttura.

Il database stesso funge da primo strumento di debug: i suoi vincoli di integrità bloccano sul nascere dati incoerenti, segnalandoci subito eventuali errori logici. Lato logging, Docker ci permette di aggregare tutto in un unico flusso, correlando facilmente l'autenticazione di Keycloak con la logica di business. Infine, abbiamo adottato una nomenclatura semantica che rende lo schema del database auto-esplicativo, riducendo drasticamente la necessità di consultare documentazione esterna.

\newpage

\subsection{Strategie per scalabilità futura}

Guardando al futuro, abbiamo progettato il sistema per non essere un sistema chiuso, ma pronto a scalare. La scelta di un backend stateless, basato su token JWT e Keycloak, è fondamentale: ci permetterebbe di aggiungere nuove istanze server in parallelo senza dover modificare una sola riga di codice. Inoltre, abbiamo protetto le prestazioni del database separando fisicamente gli allegati pesanti dai dati testuali e pre-calcolando indici strategici sulle tabelle critiche, garantendo così tempi di risposta rapidi anche qualora il numero di issue dovesse crescere drasticamente.

\newpage

\section{Descrizione della logica di base (Backend)}

Il backend del sistema BugBoard26 implementa le funzionalità server-side di una piattaforma dedicata al Bug Tracking e alla gestione collaborativa delle problematiche software. Il sistema è stato sviluppato utilizzando l'ambiente di runtime Node.js e il framework Express, avvalendosi del driver nativo pg per un'interazione performante e diretta con il database relazionale PostgreSQL.

L'architettura software adotta il pattern Layered Architecture (architettura a livelli), strutturando il codice in strati logici con responsabilità distinte: le Routes per la definizione degli endpoint, i Controllers per l'elaborazione delle richieste e il Data Access Layer per l'interazione con il database. La comunicazione tra client e server è gestita tramite API REST, mentre la sicurezza è delegata all'Identity Provider Keycloak, che gestisce l'autenticazione e l'autorizzazione attraverso standard OpenID Connect e token JWT. L'intera infrastruttura, inclusi database e servizi di supporto, è containerizzata e orchestrata tramite Docker, assicurando coerenza tra gli ambienti di sviluppo e produzione.

\subsection{Gestione delle Dipendenze}

Moduli ES6 e Pattern Singleton Per mantenere l'architettura snella e performante, il backend evita l'introduzione di complessi container di Inversion of Control (IoC). La gestione delle dipendenze è affidata al sistema nativo di ES6 Modules, implementando il Pattern Singleton per la connessione al database. L'istanza di Sequelize e i relativi modelli vengono inizializzati una singola volta all'avvio (Database.js) e importati staticamente nei controller. Questa scelta riduce drasticamente l'overhead a runtime e semplifica il tracciamento del flusso di esecuzione ("Code Navigation"), pur mantenendo una chiara separazione tra la logica di accesso ai dati e la logica di business.

\newpage

\subsection{Gestione della Concorrenza e Integrità Transazionale}

Data la natura collaborativa di BugBoard26, la gestione di accessi concorrenti è critica (es. due utenti che commentano contemporaneamente o un utente che commenta mentre un admin chiude la issue). La concorrenza è gestita delegando l'atomicità al livello più robusto: il Database Relazionale (PostgreSQL).

\begin{itemize}
  \item \textbf{Transazioni Applicative (Sequelize Hooks)} \\
        La logica di validazione critica è incapsulata in Hooks del modello ORM che operano all'interno di transazioni database. Ad esempio, prima di creare un commento, il sistema verifica lo stato della Issue all'interno della stessa transazione SQL dell'inserimento. Questo approccio (Pessimistic Check) previene race conditions in cui un commento potrebbe essere registrato su una issue che è stata chiusa millisecondi prima.
  \\
  \item \textbf{Non-Blocking I/O} \\
        A livello di server, l'architettura Event-Driven di Node.js gestisce la concorrenza delle richieste HTTP tramite un singolo thread e un Event Loop non bloccante. Questo permette al sistema di scalare su un alto numero di connessioni simultanee (I/O bound) senza il costoso overhead del context-switching tipico dei modelli thread-per-request.
\end{itemize}

\newpage

\section{Logica di Implementazione del Backend}

\subsection{L'adozione di Express.js e la Middleware Pipeline}

Il cuore del layer applicativo è costruito sul framework \textbf{Express.js}, scelto per la sua leggerezza e flessibilità nel gestire architetture basate su API REST. L'implementazione segue il pattern della \textit{Chain of Responsibility} attraverso una pipeline di middleware configurata per elaborare le richieste HTTP in ingresso in modo sequenziale e modulare.

Analizzando il punto di ingresso del server, la pipeline è strutturata in fasi distinte per garantire sicurezza e correttezza prima che la richiesta raggiunga la logica di business:

\begin{itemize}
    \item \textbf{Sicurezza degli Header (Helmet)} \\
    Come prima linea di difesa, viene utilizzato il middleware \texttt{helmet}. Questo modulo si occupa di impostare vari header HTTP relativi alla sicurezza, disabilitando header potenzialmente rischiosi come \texttt{X-Powered-By}, che potrebbero rivelare informazioni sulla tecnologia sottostante agli attaccanti, riducendo la superficie di attacco del server.
    \\
    \item \textbf{Gestione CORS (Cross-Origin Resource Sharing)} \\
    Dato che il frontend (Angular) e il backend risiedono su domini o porte differenti (rispettivamente 4200 e 3000 in sviluppo), è stata implementata una configurazione CORS rigorosa. Il sistema accetta richieste solo dall'origine del client specificata nelle variabili d'ambiente (\texttt{CLIENT\_URL}), permettendo esclusivamente i metodi HTTP necessari (GET, POST, PUT, DELETE) e l'invio di credenziali (cookie/token) tramite l'opzione \texttt{credentials: true}.
    \\
    \item \textbf{Parsing e Gestione Dati} \\
    Le richieste in ingresso vengono elaborate da \texttt{express.json()} per il parsing dei payload JSON e da \texttt{cookie-parser} per la lettura dei cookie sicuri, fondamentali per il mantenimento della sessione utente.
    \\
    \item \textbf{Integrazione con Keycloak (Auth Middleware)} \\
    Il middleware di autenticazione di Keycloak è posizionato strategicamente prima delle rotte API. Utilizzando una gestione di sessione basata su memoria (\texttt{MemoryStore}), il backend intercetta le richieste per verificare la validità del token JWT o la presenza di una sessione attiva, agendo da gatekeeper per tutte le risorse protette.
\end{itemize}

\newpage

\subsection{Organizzazione e Routing delle API}

L'architettura delle rotte segue un approccio RESTful, segregando le funzionalità in moduli distinti per migliorare la manutenibilità e la navigabilità del codice. Le rotte sono prefissate dal path \texttt{/api} per distinguere chiaramente le chiamate di servizio dalle risorse statiche o di navigazione.

La struttura delle rotte rispecchia le entità del dominio modellate nel database:

\begin{itemize}
    \item \texttt{/api/auth}: Gestisce i flussi di autenticazione, logout e refresh dei token, interfacciandosi direttamente con l'Identity Provider.
    \item \texttt{/api/users}: Espone endpoint per la gestione dei profili utente e la sincronizzazione dei dati anagrafici tra Keycloak e il database locale.
    \item \texttt{/api/projects}: Gestisce il ciclo di vita dei progetti, inclusa la creazione e l'assegnazione dei membri del team.
    \item \texttt{/api/issues}: Rappresenta il core del bug tracker, permettendo operazioni CRUD sui ticket e gestendo logiche complesse come l'upload degli allegati.
    \item \texttt{/api/comments}: Gestisce l'interazione collaborativa, permettendo l'aggiunta e la visualizzazione dei commenti collegati alle issue.
\end{itemize}

Infine, il server espone una rotta statica dedicata \texttt{/uploads}, servita direttamente da Express, per permettere al frontend di recuperare in modo performante gli asset (immagini o documenti) caricati dagli utenti, mantenendo i file fisici separati dalla logica applicativa ma accessibili via HTTP.

\subsection{Gestione Avanzata delle Autorizzazioni e RBAC}

Oltre all'autenticazione gestita da Keycloak, il sistema implementa un controllo degli accessi basato sui ruoli, \textbf{Role-based access control} (RBAC), direttamente nel layer applicativo tramite middleware personalizzati.

Un esempio critico è il middleware \texttt{canModifyIssue}, che regola l'accesso alle operazioni di modifica e cancellazione. La logica implementata distingue dinamicamente i permessi in base al ruolo e alla proprietà della risorsa:
\begin{itemize}
    \item \textbf{Ruolo Amministratore}\\
          Se il token JWT contiene il ruolo \textit{Amministratore} (verificato analizzando sia i ruoli del realm che quelli del client), l'operazione viene sempre consentita, garantendo la supervisione totale del sistema.
    \\
    \item \textbf{Utente Standard (Owner)}\\
          Se l'utente non è amministratore, il middleware esegue una query puntuale sul database per verificare se l'ID dell'utente autenticato corrisponde al campo \texttt{id\_creatore} dell'issue target. In caso negativo, la richiesta viene respinta con un codice 403 (Forbidden), impedendo la modifica di risorse altrui.
\end{itemize}

\newpage

\subsection{Implementazione delle Regole di Business}

I controller non si limitano a operazioni CRUD elementari, ma incapsulano regole di dominio specifiche per garantire l'integrità e la tracciabilità dei dati. Analizzando l'\texttt{issueController}, emergono tre pattern implementativi rilevanti:

\begin{itemize}
    \item \textbf{Integrità e Sicurezza degli Allegati} \\
    Durante l'upload, il sistema non si limita a salvare i file. Per ogni allegato viene calcolato l'hash \textbf{SHA256} del contenuto binario tramite il modulo \texttt{crypto} di Node.js. Questo hash viene salvato nel database per garantire l'integrità del dato e la verifica di non alterazione nel tempo. Inoltre, viene applicata una validazione pre-upload che impedisce di superare il limite di 3 allegati per issue, interrogando il database per contare gli allegati esistenti prima di accettarne di nuovi.

    \item \textbf{Audit Trail delle Modifiche (Append-Only)} \\
    Per preservare la storia delle modifiche, l'aggiornamento della descrizione di una issue non sovrascrive il testo precedente. Il sistema utilizza una logica \textit{append-only}: la nuova descrizione viene accodata a quella esistente, separata da un header temporale generato lato server (timestamp). Questo garantisce che nessuna informazione venga persa e fornisce una cronologia immediata dell'evoluzione del ticket.

    \item \textbf{Transazionalità e Pulizia (Rollback)} \\
    In caso di errori durante la creazione complessa di una issue (es. fallimento della query SQL dopo l'upload fisico dei file), viene attivata una procedura di \textit{cleanup}. Il sistema intercetta l'eccezione e rimuove fisicamente dal filesystem i file appena caricati ma orfani di record nel database, prevenendo l'inconsistenza dello storage.
\end{itemize}

\newpage

\section{Modello dei Dati Backend}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/class_Diagram_Backend.pdf}
\end{figure}

\newpage

\section{Qualità del Codice}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/sonarqube.png}
\end{figure}

\subsection{Documentazione}

Oltre a questa documentazione tecnica, il codice include commenti dove la logica non è immediatamente ovvia.

\newpage

\subsection{Deployment e Configurazione}

\subsubsection{Configurazione}

Il sistema utilizza file YAML per la configurazione, con supporto per override tramite variabili d'ambiente. Questo approccio permette di mantenere la stessa build per diversi ambienti, cambiando solo la configurazione.

I parametri configurabili includono connessione al database, credenziali Keycloak, varie configurazioni di Keycloak, porte usate.

\subsubsection{Containerizzazione}

L'applicazione è containerizzata usando Docker, con un Dockerfile ottimizzato per produrre immagini minimal. Il container espone solo la porta necessaria e include health check per facilitare l'orchestrazione.

\newpage

\section{Descrizione e motivazione delle scelte di design dell’interfaccia utente adottate (Frontend)}

\subsection{Introduzione}

Il frontend dell'applicazione BugBoard26 è un sistema completo per la gestione di issue legate a dei progetti sviluppato come applicazione web SPA (Single Page Application) utilizzando Angular con l'ausilio di Tailwind. L'applicazione rappresenta un esempio di implementazione moderna che integra pattern architetturali consolidati con tecnologie all'avanguardia per creare un'esperienza utente fluida e manutenibile.

L'obiettivo principale del progetto è fornire una piattaforma che permetta alle software house e singoli, di tenere traccia di ogni bug presente nelle loro applicazioni e per supervisionare l'andamento della risuluzione dei tali.

\subsection{Architettura e Pattern Fondamentali}

\subsubsection{Component-Bases Architetture}

L'applicazione frontend implementa un'architettura rigorosamente Component-Based, organizzata secondo il pattern "Smart vs Dumb Components". Questa scelta garantisce che la logica di business e di recupero dati sia disaccoppiata dalla logica di presentazione visiva. I componenti "Smart" (o Container) agiscono come orchestratori: gestiscono lo stato della pagina, interagiscono con i servizi e passano i dati verso il basso. I componenti "Dumb" (o Presentational) sono puramente funzionali alla visualizzazione: ricevono dati tramite input, emettono eventi tramite output e rimangono agnostici rispetto al contesto applicativo, massimizzando la riusabilità del codice UI attraverso l'intera applicazione.

\subsubsection{Programmazione Reattiva con RxJS}

Al posto di pattern imperativi, l'applicazione adotta il paradigma della Programmazione Reattiva sfruttando la libreria RxJS. Questo approccio permette di gestire i flussi di dati asincroni (chiamate HTTP, eventi utente, input form) come stream continui (Observables). L'utilizzo degli Observables garantisce una gestione elegante della complessità asincrona: i componenti sottoscrivono i flussi di dati forniti dai servizi e reagiscono automaticamente ai cambiamenti di stato. Questo elimina la necessità di callback nidificate e permette di trasformare, filtrare e combinare i dati in arrivo dal backend prima che questi raggiungano la vista, garantendo che l'interfaccia utente rifletta sempre lo stato più aggiornato dei dati in modo predicibile.

\newpage

\subsubsection{Service Layer Pattern}

Il Service Layer rappresenta l'incarnazione della logica di business nel frontend, centralizzando la comunicazione con le API REST del backend. I servizi Angular incapsulano la complessità delle chiamate di rete, la gestione degli header di autenticazione (tramite Interceptor) e la gestione degli errori. Delegando la logica di interazione dati ai servizi, i componenti (ViewModel) rimangono snelli e focalizzati esclusivamente sulla gestione dello stato della vista. I servizi sono progettati come Singleton, garantendo una gestione efficiente delle risorse e permettendo la condivisione dello stato tra diversi componenti quando necessario, senza duplicazione di logica.

\subsubsection{Single Responsibility Principle (SRP)}

Il principio di singola responsabilità permea l'intera struttura del progetto attraverso una granularità fine dei moduli. Nel frontend, ogni componente UI ha una responsabilità visiva unica (es. una card per le issue, una sidebar di navigazione), mentre la logica è delegata ai servizi. Nel backend, la separazione è garantita dall'uso di middleware per compiti trasversali (autenticazione, upload file, gestione errori) e controller distinti per ogni entità di dominio. Questa separazione meticolosa facilita la manutenzione evolutiva: la modifica della logica di validazione di un form, ad esempio, è isolata nel relativo componente o servizio, senza rischio di regressioni in parti non correlate del sistema.

\subsubsection{Angular Dependency Injection}

L'applicazione sfrutta il potente sistema di Dependency Injection (DI) nativo di Angular per gestire le dipendenze in modo dichiarativo e gerarchico. Questo pattern inverte il controllo della creazione degli oggetti: i componenti non istanziano le proprie dipendenze (come i servizi HTTP), ma le ricevono iniettate dal framework a runtime. L'approccio Type-Safe della DI di Angular non solo riduce l'accoppiamento tra le classi, ma facilita enormemente il testing unitario. È possibile, infatti, sostituire facilmente le implementazioni reali dei servizi con Mock o Stub durante i test, verificando il comportamento dei componenti in isolamento senza dover effettuare reali chiamate di rete.

\newpage

\subsection{Organizzazione delle Directory}

L'organizzazione del codice sorgente nel client Angular riflette una chiara distinzione tra le funzionalità di business (Pagine) e le risorse infrastrutturali o condivise. La struttura della directory src/app adotta una convenzione visiva immediata basata sull'uso di prefissi:

\begin{itemize}
  \item \textbf{Directory Core e Shared (Prefisso \texttt{\_}):} Le cartelle che iniziano con underscore raggruppano elementi trasversali e non accessibili direttamente tramite routing.
        \begin{itemize}
          \item \texttt{\_services}: Centralizza la logica di comunicazione HTTP e la gestione dello stato, isolandola dai componenti.
          \item \texttt{\_internalComponents}: Contiene i componenti "Dumb" riutilizzabili (es. card, modali, elementi UI) che costituiscono i mattoni dell'interfaccia.
          \item \texttt{\_auth} e \texttt{\_config}: Custodiscono rispettivamente le guardie di navigazione (Guards) e le configurazioni globali (es. inizializzazione Keycloak).
        \end{itemize}
  \item \textbf{Directory Feature (Pagine):} Le cartelle senza prefisso (es. \texttt{dashboard}, \texttt{project}, \texttt{users}) rappresentano le viste principali dell'applicazione. Ogni directory incapsula tutto il necessario per quella specifica rotta, agendo come un modulo funzionale autonomo.
\end{itemize}