\chapter{Documento di Design del sistema}

\section{Obiettivi di Design}

Gli obiettivi di design del sistema si basano sugli attributi di qualità del software definiti nello
standard ISO/IEC 25002. Per priorizzare tali obiettivi, è stato adottato un sistema di
ponderazione da 1 a 5, dove 5 indica la massima priorità, in funzione dell'impatto specifico di
ciascuna caratteristica sulle funzionalità da implementare.

\subsection{Analisi delle Caratteristiche di Qualità}

\begin{itemize}
  \item \textbf{Functional Suitability (5/5)} \\
        L'idoneità funzionale è centrale per garantire che il flusso di gestione delle anomalie supporti efficacemente il processo di QA aziendale.
        La \textbf{functional completeness (5/5)} è garantita dalla copertura esaustiva dei casi d'uso necessari per il tracking, inclusa la creazione di issue con tipologie diversificate (Bug, Feature, Question), la gestione di allegati e il sistema di commenti per la collaborazione.
        La \textbf{functional correctness (5/5)} è assicurata dalle rigorose validazioni implementate nel backend, che prevengono la creazione di ticket con dati incompleti o incoerenti, e verificata tramite test automatici specifici.
        La \textbf{functional appropriateness (5/5)} si riflette nella segregazione dei compiti tra ruoli "Standard" e "Admin", fornendo a ciascun utente esattamente le funzionalità pertinenti al proprio livello di responsabilità.
  \\
  \item \textbf{Reliability (4/5)} \\
        L'affidabilità del sistema è solida, garantendo continuità e robustezza operativa. La \textbf{faultlessness (4/5)} è perseguita attraverso l'uso di strumenti di analisi statica e una suite di test automatizzati con \texttt{Vitest} che verifica il comportamento corretto delle API, riducendo la presenza di difetti nel codice.
        L'\textbf{Availability (4/5)} è assicurata dall'architettura containerizzata: i servizi critici come Postgres e Keycloak dispongono di healthcheck dedicati che prevengono l'avvio del backend finché le dipendenze non sono operative, massimizzando il tempo di attività del servizio.
        La \textbf{fault tolerance (4/5)} è gestita efficacemente a livello applicativo; i controller utilizzano blocchi try/catch per intercettare eccezioni impreviste senza causare il crash dell'intero servizio, restituendo invece errori strutturati al client.
        La \textbf{recoverability (3/5)} è implementata tramite meccanismi di rollback manuale, come la funzione cleanupFiles che elimina i file caricati se la transazione di creazione della issue fallisce, ripristinando uno stato consistente del sistema.
  \newpage
  \item \textbf{Security (5/5)} \\
        La sicurezza è gestita in modo rigoroso, adottando standard industriali per la protezione del sistema. La \textbf{confidentiality (5/5)} è garantita dall'integrazione con Keycloak, che protegge le risorse tramite token JWT cifrati; l'accesso agli endpoint sensibili è regolato da middleware come protect e checkRole, assicurando che solo gli utenti autorizzati visualizzino i dati.
        L'\textbf{integrity (5/5)} è assicurata per gli allegati tramite il calcolo dell'hash SHA256 al momento dell'upload, permettendo di verificare che i file non siano stati alterati.
        L'\textbf{authenticity (5/5)} viene verificata crittograficamente: il backend valida la firma digitale dei token JWT utilizzando le chiavi pubbliche (JWKS) esposte da Keycloak, garantendo con certezza l'identità del mittente.
        La \textbf{non-repudiation (4/5)} è supportata dalla persistenza dei dati: ogni issue e commento creato è indissolubilmente legato all'ID univoco dell'utente nel database, rendendo innegabile la paternità dell'azione all'interno del sistema.
        Infine, l'\textbf{accountability (5/5)} è totale, poiché ogni richiesta che modifica lo stato del sistema passa attraverso il middleware di autenticazione che traccia l'utente responsabile prima di eseguire qualsiasi operazione sui controller.
  \\
  \item \textbf{Performace Efficiency (3/5)} \\
        L'efficienza risente della centralizzazione della logica nel layer backend monolitico. Il \textbf{time behaviour (3/5)} è penalizzato da alcune implementazioni nel layer di accesso ai dati, come il problema "N+1" nel controller delle issue che esegue una query di conteggio per ogni elemento restituito, rallentando la risposta complessiva del server.
        La \textbf{resource utilization (3/5)} è critica nel layer applicativo, poiché la gestione degli allegati carica interi file in buffer di memoria direttamente nel processo Node.js principale, rischiando di saturare le risorse del container backend in caso di picchi di utilizzo.
        La \textbf{capacity (4/5)} rimane comunque buona grazie alla separazione netta degli strati via Docker Compose, che permette di allocare risorse dedicate o scalare il layer backend indipendentemente dal database e dal frontend.
  \\
  \item \textbf{Usability (4/5)} \\
        L'usabilità è progettata per garantire un'interazione intuitiva e accessibile. La \textbf{recognizability (5/5)} è eccellente: la presenza di una dashboard iniziale con grafici a torta permette agli utenti di comprendere immediatamente lo scopo del sistema e lo stato corrente delle issue, mentre la navigazione tramite sidebar rende esplicite le funzionalità disponibili.
        L'\textbf{inclusivity (4/5)} è supportata dall'adozione del framework Angular Material, che fornisce componenti nativamente accessibili (come campi di input con etichette chiare e contrasto adeguato), facilitando l'uso anche a utenti con diverse abilità visive.
        La \textbf{learnability (4/5)} è favorita da un'interfaccia coerente e moderna (Tailwind CSS), che riduce la curva di apprendimento per i nuovi membri del team.
        L'\textbf{operability (4/5)} è garantita da flussi di lavoro lineari e dialoghi di conferma (es. toast) che prevengono errori operativi durante azioni critiche come l'eliminazione.
  \newpage
  \item \textbf{Compatibility (5/5)} \\
        La compatibilità è essenziale per l'integrazione in ambienti di sviluppo eterogenei. La \textbf{co-existence (5/5)} è eccellente grazie all'uso di Docker Compose, che isola completamente le dipendenze (DB, Keycloak, Backend) evitando conflitti con altro software installato sulla macchina host.
        L'\textbf{interoperability (5/5)} è garantita dall'adozione di standard aperti come REST per le API, JSON per lo scambio dati e OIDC per l'autenticazione, permettendo al sistema di dialogare facilmente con altri strumenti aziendali.
  \\
  \item \textbf{Maintainability (5/5)} \\
        La manutenibilità è un punto di forza, strutturata per facilitare evoluzioni future. La \textbf{modularity (5/5)} è garantita dalla netta separazione delle responsabilità nel backend tra controller, rotte e modelli dati, e nel frontend tramite l'architettura a componenti di Angular.
        La \textbf{reusability (5/5)} è massimizzata dall'uso di middleware generici per funzioni trasversali come l'autenticazione e la gestione dei file, riutilizzabili su diverse rotte.
        La \textbf{testability (5/5)} è assicurata da un'infrastruttura di testing pronta con l'utilizzo di \texttt{Vitest}.
        La \textbf{modifiability (5/5)} è supportata dall'uso dell'ORM Sequelize, che astrae le query SQL permettendo di modificare lo schema del database o la logica di business con impatti minimi sul resto del codice, e dalla configurazione esternalizzata in file \texttt{.env} che facilita i cambi di ambiente senza ricompilazione.
  \\
  \item \textbf{Flexibility (4/5)} \\
        La flessibilità determina la capacità del software di adattarsi a nuovi contesti e tecnologie. L'\textbf{adaptability (4/5)} è gestita tramite un ampio uso di variabili d'ambiente che permettono di riconfigurare database, porte e URL di servizi esterni senza modificare il codice sorgente.
        La \textbf{scalability (4/5)} è intrinseca nell'architettura a container, permettendo di scalare orizzontalmente i servizi stateless come il backend e il frontend.
        L'\textbf{installability (3/5)} è buona grazie a Docker Compose, ma il punteggio è ridotto dalla necessità di configurare manualmente il file .env prima dell'avvio, introducendo un passaggio manuale obbligatorio che impedisce un deployment totalmente automatico "out-of-the-box".
        Infine, la \textbf{replaceability (4/5)} è supportata dall'uso dell'ORM Sequelize, che facilita la sostituzione del database PostgreSQL con altri dialetti SQL minimizzando le modifiche al codice.
  \\
  \item \textbf{Safety (3/5)} \\
        La sicurezza intesa come assenza di rischi (Safety) riguarda la prevenzione di danni critici. Sebbene in un bug tracker il rischio fisico sia nullo, l'\textbf{operational safety (3/5)} è garantita da meccanismi che prevenendo la corruzione dei dati o l'accumulo di "rifiuti" digitali, come la cancellazione automatica dei file caricati se la transazione database fallisce.
        La \textbf{risk identification (3/5)} è mitigata dalle restrizioni sui ruoli, impedendo che utenti inesperti possano compromettere la configurazione dei progetti o degli utenti critici.
\end{itemize}

\newpage

\subsection{Tabella riassuntiva delle priorità delle qualità del software}

Di seguito è presentata una tabella riassuntiva delle valutazioni di priorità assegnate alle qualità
del software analizzate.

\begin{longtable}{|>{\centering\arraybackslash\bfseries}p{7cm}|p{7cm}|}
  \hline
  \rowcolor{airforceblue!80!cyan}
  \textcolor{white}{\textbf{Qualità}} & \textcolor{white}{\textbf{Punteggio}} \\
  \hline
  \endfirsthead
  \endhead

  \rowcolor{beaublue!30}
  \textit{Functional suitability} & 5 \\ \hline
  Reliability  & 4 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Security} & 5 \\ \hline
  Performace Efficiency & 3 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Usability} & 4 \\ \hline
  Compatibility & 5 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Maintainability} & 5 \\ \hline
  Flexibility & 4 \\ \hline
  \rowcolor{beaublue!30}
  \textit{Safety} & 3 \\ \hline
\end{longtable}

\newpage

\subsection{Considerazioni sul Tempo di rilascio e Trade-offs}

Il \textbf{Time to Release} rappresenta un vincolo critico del progetto, subordinato esclusivamente alla \textit{Functional Suitability} e alla \textit{Security}. La pressione temporale imposta dalle scadenze operative ha determinato trade-offs consapevoli tra qualità del software concorrenti, privilegiando il rilascio rapido di funzionalità essenziali rispetto all'ottimizzazione spinta di attributi secondari.

\begin{itemize}
  \item \textbf{Time to Release vs Code Quality} \\
        L'introduzione controllata di technical debt è stata accettata per rispettare le milestone di progetto, garantendo comunque la correttezza funzionale tramite test automatizzati con \texttt{Vitest}.
  \\
  \item \textbf{Time to Release vs Performance Efficiency} \\
        L'adozione dell'ORM Sequelize ha accelerato lo sviluppo del layer di persistenza eliminando la necessità di scrivere query SQL manuali, introducendo però un overhead computazionale fisiologico. L'implementazione diretta di query ottimizzate avrebbe richiesto un dispendio temporale incompatibile con la priorità del rilascio.
  \\
  \item \textbf{Time to Release vs Functional Suitability} \\
        La definizione rigorosa del perimetro funzionale ha limitato lo scope alle funzionalità essenziali: creazione, lettura, aggiornamento ed eliminazione di issue con sistema di commenti e allegati.
  \\
  \item \textbf{Safety vs Performance Efficiency} \\
        I meccanismi di \textbf{operational safety} implementati introducono overhead elaborativo aggiuntivo per ogni transazione. La funzione \texttt{cleanupFiles} esegue operazioni di filesystem I/O sincrone per garantire la rimozione degli allegati orfani in caso di rollback del database, rallentando il throughput delle operazioni di creazione issue ma prevenendo la corruzione dello stato del sistema e l'accumulo di risorse non referenziate.
  \\
  \item \textbf{Security vs Time to Release} \\
        Nonostante la pressione temporale, la \textbf{Security} non è stata compromessa. L'integrazione con Keycloak per la gestione di autenticazione e autorizzazione tramite token JWT, la validazione crittografica delle firme digitali con JWKS, e il calcolo dell'hash SHA256 per l'integrità degli allegati sono stati implementati integralmente sin dalla prima release, riconoscendo il rischio elevato di exploitation di vulnerabilità legate a bug leak o privilege escalation.
\end{itemize}

\newpage

\section{Decomposizione del sistema}

Per poter comprendere quale architettura fosse adatta per questo progetto, abbiamo analizzato diverse alternative concentrandoci però sugli aspetti chiave di essi:

\begin{itemize}
  \item \textbf{Architetture Standard vs. Architetture Moderne} \\
        L'analisi ha confrontato l'adozione di architetture consolidate, come quella monolitica a strati (layered architecture), con paradigmi più recenti quali microservizi e architetture event-driven. Pur riconoscendo i benefici di approcci distribuiti in termini di scalabilità orizzontale, fault isolation e autonomia dei team, tali soluzioni comportano un overhead significativo nella gestione della comunicazione inter-service, nell'orchestrazione del deployment e nel monitoraggio distribuito. Considerando le caratteristiche del progetto — un perimetro funzionale ben definito, un team di sviluppo ridotto e vincoli temporali stringenti — un'architettura monolitica a strati si è rivelata la scelta ottimale, bilanciando efficacemente semplicità operativa ed efficienza nello sviluppo. Questa decisione ha consentito di allocare le risorse disponibili sull'implementazione delle funzionalità core del sistema, evitando la complessità architetturale non necessaria per la scala operativa prevista.
  \\
  \item \textbf{Persistenza dei Dati} \\
        La natura strutturata delle informazioni gestite dal sistema — issue con metadati
        tipizzati, relazioni tra utenti e progetti, commenti gerarchici e allegati referenziati —
        ha reso necessaria l'adozione di un database relazionale (RDBMS). PostgreSQL è
        stato selezionato per la sua robustezza nelle operazioni transazionali ACID,
        essenziali per garantire la consistenza tra la creazione di issue e il caricamento di
        allegati, e per il supporto nativo a vincoli di integrità referenziale che prevengono
        la corruzione dei dati in caso di operazioni concorrenti. L'integrazione con
        Sequelize ORM ha ulteriormente semplificato l'accesso ai dati, astraendo la
        complessità delle query SQL e massimizzando la \textbf{modifiability} del
        layer di persistenza. Alternative NoSQL, pur offrendo scalabilità orizzontale
        superiore, avrebbero compromesso la capacità di eseguire query complesse con
        filtri multipli (per tipo, stato, progetto, assegnatario) e join tra entità correlate,
        funzionalità core del sistema di ricerca implementato nel frontend.
  \\
  \item \textbf{Cloud vs On-Premise} \\
        Il deployment del sistema è stato progettato per ambienti cloud, sfruttando
        la containerizzazione tramite Docker Compose per garantire portabilità e
        isolamento delle dipendenze. Questa scelta elimina la necessità di gestire infrastruttura fisica dedicata e
        semplificando drasticamente le operazioni di provisioning e scaling.
        L'architettura containerizzata permette il deployment su qualsiasi provider
        cloud o su infrastrutture on-premise virtualizzate,
        mantenendo la \textbf{co-existence} con altri servizi aziendali senza
        conflitti di dipendenze. Un deployment on-premise tradizionale richiederebbe configurazioni manuali per PostgreSQL, Keycloak e Node.js su
        ciascun ambiente. La soluzione
        cloud consente inoltre di delegare aspetti infrastrutturali critici come
        backup automatici, disaster recovery e aggiornamenti di sicurezza al provider,
        liberando risorse del team per lo sviluppo delle funzionalità core.
  \newpage
  \item \textbf{Buy vs Build} \\
        Nonostante la pressione temporale derivante dal \textbf{Time to Release},
        la scelta è ricaduta sull'opzione "build", sviluppando il sistema internamente
        piuttosto che adottare soluzioni commerciali preesistenti come Jira, GitLab
        Issues o Bugzilla. Questa decisione è stata motivata principalmente da
        requisiti di \textbf{Functional Suitability} specifici per i processi di
        QA aziendali, che richiedevano workflow personalizzati e integrazioni con
        sistemi interni non supportate da strumenti generici. Tuttavia, per componenti
        infrastrutturali critici ma non differenzianti, è stata privilegiata
        l'integrazione con software open-source maturo: Keycloak in modalità headless come Identity
        Provider self-hosted garantisce standard industriali di \textbf{Security}
        (autenticazione OIDC, gestione realm con ruoli "Standard" e "Amministratore",
        validazione JWT tramite JWKS) senza dover implementare da zero logiche
        complesse di Identity and Access Management. L'infrastruttura cloud è
        affidata ad Amazon Web Services (AWS), che fornisce compute tramite EC2
        per l'esecuzione dei container Docker (frontend Angular, backend Node.js,
        database PostgreSQL e Keycloak stesso). Questo approccio ibrido ha bilanciato
        il controllo completo sulle funzionalità core del bug tracker con l'efficienza
        derivante dall'utilizzo di componenti consolidate per aspetti trasversali,
        evitando il rischio di reinventare soluzioni già disponibili e battle-tested.
  \\
  \item \textbf{Complessità del Sistema e Prospettive Future} \\
        La complessità contenuta del sistema, caratterizzato da un perimetro
        funzionale ben definito e da incertezze sulla sua evoluzione a lungo termine,
        ha reso ingiustificata l'adozione prematura di architetture distribuite come i
        microservizi, che avrebbero introdotto un livello di complessità eccessivo
        (over-engineering) rispetto alle necessità operative attuali. Tale approccio
        avrebbe inoltre compromesso significativamente il \textbf{Time to Release}, imponendo overhead di gestione, orchestrazione e monitoring
        sproporzionati alla scala del progetto. Ciononostante, la scelta di
        un'architettura containerizzata su cloud AWS e l'integrazione con servizi
        gestiti come Keycloak garantiscono la flessibilità necessaria per una
        potenziale migrazione verso pattern architetturali più distribuiti qualora le
        esigenze future del sistema richiedano maggiore scalabilità orizzontale,
        resilienza o autonomia dei componenti. L'adozione di standard aperti
        (REST API, OIDC, Docker) e la separazione netta dei layer preservano la
        \textbf{modifiability} necessaria per evolvere l'architettura senza
        riscritture sostanziali del codice esistente.
\end{itemize}